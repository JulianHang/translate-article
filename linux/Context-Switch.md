### 上下文切换，翻译地址：http://www.linfo.org/context_switch.html

```java

    /**
    
    上下文切换（有时也称为过程开关或任务开关）是CPU（中央处理单元）从一个进程或线程切换到另一个进程或线程.
    
    一个进程（有时也称为任务）是程序的执行（运行）实例. 在Linux中，线程是轻量级进程，可以并行运行，并与其父进程（即创建它们的进程）共享地址空间（即一系列内存位置）和其他资源.
    
    上下文是在任何时间点CPU的寄存器和程序计数器的内容. 寄存器是CPU内部的少量非常快的内存，用于通过提供对常用值的快速访问来加速计算机程序的执行. 程序计数器是一个专用寄存器，它指示CPU在其指令序列中的位置，并取决于特定的系统，该寄存器保存正在执行的指令的地址或要执行的下一条指令的地址. 

    当内核（即操作系统的核心）针对CPU上的进程（包括线程）执行以下活动时，可以更详细地描述上下文切换：1、暂停一个进程的进程并将该进程的CPU状态（即上下文）存储在内存中的某个位置  2、从内存中检索下一个进程的上下文，并将其还原到CPU的寄存器中  3、返回到程序计数器指示的位置（即返回到中断处理的代码行）以恢复该过程.

    上下文切换有时被描述为内核在CPU上挂起一个进程的执行并恢复以前已挂起的其他进程的执行. 尽管此措辞可以帮助阐明概念，但它本身可能会造成混淆，因为根据定义，流程是程序的执行实例. 因此，中止进程的措辞可能是更可取的.

    上下文切换和模式切换

    上下文切换只能在内核模式下发生. 内核模式是CPU的特权模式，仅内核在其中运行，并提供对所有内存位置和所有其他系统资源的访问. 其他程序（包括应用程序）最初在用户模式下运行，但是它们可以通过系统调用来运行部分内核代码. 系统调用是类活动的进程在类Unix操作系统中对内核执行的服务（例如输入/输出（I / O）或进程创建）的请求. I / O可以定义为信息往返于CPU和主内存（即RAM）之间的任何移动，即此组合与计算机用户，其存储设备或其他计算机之间的通信. 

    在类Unix操作系统中，这两种模式的存在意味着，当系统调用导致CPU转换为内核模式时，必须进行类似但更简单的操作. 这被称为模式切换而不是上下文切换，因为它不会更改当前进程.
    
    上下文切换是多任务操作系统的基本功能. 多任务操作系统是其中多个进程看似同时且在彼此之间互不干扰的单个CPU上执行的操作系统. 并发的这种幻觉是通过快速连续（每秒数十或数百次）发生的上下文切换来实现的. 这些上下文切换是由于进程自愿放弃其在CPU中的时间而导致的，或者是由于在进程用完其CPU时间片时调度程序进行切换而导致的. 
    
    上下文切换也可能由于硬件中断而发生，这是从硬件设备（例如键盘，鼠标，调制解调器或系统时钟）到内核的事件（例如按键，鼠标移动）的信号 或来自网络连接的数据到达）.
    
    Intel 80386和更高版本的CPU包含对上下文切换的硬件支持. 但是，大多数现代操作系统都执行软件上下文切换（可在任何CPU上使用），而不是尝试进行硬件上下文切换以获得更高的性能. 软件上下文切换最早是在Linux中针对具有2.4内核的Intel兼容处理器实现的.

    软件上下文切换所声称的一个主要优点是，尽管硬件机制可以保存几乎所有的CPU状态，但是软件可以更具选择性，并且只保存实际需要保存和重新加载的那一部分. 但是，对于这在提高上下文切换效率方面到底有多重要，存在一些疑问。 它的倡导者还声称，软件上下文切换允许改进切换代码的可能性，从而进一步提高效率，并且它允许更好地控制正在加载的数据的有效性.

    上下文切换的成本

    上下文切换通常需要大量计算. 也就是说，这需要相当长的处理器时间，对于每秒数十或数百个开关而言，这可能要在纳秒量级。 因此，就CPU时间而言，上下文切换对系统而言是相当大的成本，并且实际上可能是操作系统上最昂贵的操作. 
    
    因此，操作系统设计的主要重点是尽可能避免不必要的上下文切换。 但是，这在实践中并不容易实现. 实际上，尽管根据消耗的CPU时间的绝对数量来衡量上下文切换的成本一直在下降，但这似乎主要是由于CPU时钟速度的提高，而不是上下文切换本身的效率的提高. 

    与其他操作系统（包括某些其他类似Unix的系统）相比，Linux的众多优势之一是其上下文切换和模式切换的成本极低.

    /


```