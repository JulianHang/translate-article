### 翻译内存模式，引入Java Language Specification（Java说明书），可自行Google下载针对版本

```java

    /**

     内存模型在给定程序和程序的执行跟踪的情况下，描述该执行跟踪是否为该程序的合法执行（很抽象）. Java编程语言内存模型通过检查执行跟踪中的每个读取并根据某些规则检查该读取所观察到的写入是否有效来工作.

     内存模型描述了程序的可能行为. 只要程序的所有最终执行都产生可以由内存模型预测的结果，实现就可以自由生成其喜欢的任何代码. 

        这为实现者提供了大量的代码执行自由的转换，包括动作的重新排序和不必要的同步的删除.
     
        错误同步的程序可能表现出令人惊讶的行为.

        Java编程语言的语义允许编译器和微处理器执行优化，这些优化可以以不正确的方式与不正确的代码进行交互，从而产生看似矛盾的行为（没理解）. 这是一些示例，说明不正确的同步程序可能会表现出令人惊讶的行为.

        例如，考虑表17.4-A中显示的示例程序跟踪. 该程序使用局部变量r1和r2以及共享变量A和B. 最初，A == B == 0. 

        语句重新排序导致令人惊讶的结果-原始代码

        Thread1                                                Thread2
        1：r2 = A；                                            3：r1 = B；
        2：B = 1；                                             4：A = 2；

        看起来结果r2 == 2和r1 == 1是不可能的. 直观地讲，指令1或指令3应该在执行中排在最前面. 如果指令1首先出现，则应该看不到指令4的内容. 如果指令3首先出现，则应该看不到指令2的内容. 

        如果某些执行表现出这种行为，那么我们将知道指令4在指令1之前，指令1在指令2之前，指令2在指令3之前，指令3在指令4之前（形成了闭环，有问题）. 从表面上看，这是荒谬的.

        但是，当编译器不影响单独执行该线程时，允许编译器在两个线程中对指令进行重新排序. 如果将指令1与指令2重新排序，如表17.4-B中的轨迹所示，那么很容易看到结果r2 == 2和r1 == 1可能如何发生.

        语句重新排序导致令人惊讶的结果-有效的编译器转换

        Thread 1                                               Thread 2
        B = 1；                                                 r1 = B；
        r2 = A；                                                A = 2；

        对于某些程序员来说，这种行为可能看起来"破碎". 但是，应注意，此代码未正确同步：

        - 在一个线程中有一个写入

        - 有另一个线程读取同一变量，并且写入和读取未按同步进行排序（它的意思是两个线程对同一个变量的读写顺序不同吗？）

        这种情况是数据争用的一个示例（第17.4.5节）。 当代码包含数据竞争时，通常可能会产生违反直觉的结果.

        几种机制可以产生表17.4-B中的重新排序. Java虚拟机实现中的即时编译器或处理器可能会重新排列代码. 此外，运行Java虚拟机实现的体系结构的内存层次结构可能会使它看起来好像正在对代码进行重新排序. 在本章中，我们将引用可以重新排序代码的任何内容作为编译.

        令人惊讶的结果的另一个例子可以在表17.4-C中看到. 最初，p == q和p.x == 0. 该程序也被错误地同步；它写入共享内存，而没有在这些写入之间强制执行任何排序.

        正向替代引起的惊人结果

        Thread 1                                               Thread 2
        r1 = p;                                                r6 = p;
        r2 = r1.x;                                             r6.x = 3;
        r3 = q;
        r4 = r3.x;
        r5 = r1.x;
        
        一种常见的编译器优化涉及到将r2的读取值重用于r5：它们都是对r1.x的读取，没有中间写入. 表17.4-D显示了这种情况.

        Thread 1                                               Thread 2
        r1 = p;                                                r6 = p;
        r2 = r1.x;                                             r6.x = 3;
        r3 = q;
        r4 = r3.x;
        r5 = r2;

        现在考虑以下情况：线程2中对r6.x的分配发生在第一次读取r1.x与读取线程1中的r3.x之间. 如果编译器决定将r2的值重用于r5，则r2和r5的值为0，r4的值为3. 从程序员的角度来看，存储在p.x的值已从0更改为3，然后又变回原来的值（0）.

        内存模型决定了在程序里每个点都可以读取哪些值. 单独的每个线程的行为必须遵循该线程的语义，除非每次读取所看到的值由内存模型确定. 当我们提到这个时，我们说程序遵循线程内语义. 线程内语义是单线程程序的语义，并允许基于线程内的读取操作看到的值来完全预测线程的行为. 为了确定线程t在执行中的动作是否合法，我们只需要评估线程t的实现，就像在本规范的其余部分所定义的那样，它将在单线程上下文中执行.

        对线程t的每一次评估生成inter-thread操作时，它必须与程序顺序中接下来出现的t的inter-thread操作a相匹配. 如果读取a，则对t的进一步评估将使用内存模型确定的a所看到的值.

        本节提供了Java编程语言内存模型的规范，但涉及final字段的问题除外，这在§17.5中进行了描述.

            本文指定的内存模型从根本上不是基于Java编程语言的面向对象性质. 为了使示例简洁明了，我们经常展示没有类或方法定义或显式取消引用的代码片段. 大多数示例由两个或多个线程组成，这些线程包含可访问局部变量，共享全局变量或对象的实例字段的语句. 我们通常使用诸如r1或r2之类的变量名称来表示方法或线程本地的变量。 此类变量无法由其他线程访问.

    


    共享变量（Shared Variables）

    可以在线程之间共享的内存称为共享内存或堆内存. 

    所有实例字段，静态字段和数组元素都存储在堆内存中. 在本章中，我们使用术语变量来指代字段和数组元素.

    局部变量，形参和异常处理程序参数永远不会在线程之间共享，并且不受内存模型的影响.

    如果至少一个访问是写操作，则对同一变量的两次访问（读或写）被认为是冲突的.




    动作（Actions）

    线程间操作是由一个线程执行的操作，可以被另一个线程检测或直接影响该操作. 程序可以执行多种线程间操作：

    - 正常读取变量（非volatile修饰）

    - 正常写入变量（非volatile修饰）

    - 同步操作，这些操作是：

        - 读取volatile修饰的变量

        - 写入volatile修饰的变量

        - 锁住对象

        - 解锁对象

        - 线程的（综合）第一个和最后一个动作

        - 启动线程或检测到线程已终止的操作
    
    - 外部动作. 外部动作是在执行外部可以观察到的动作，其结果基于执行外部的环境.

    - 线程分歧动作. 线程分歧操作仅由处于无限循环中的线程执行，在该循环中不执行任何内存，同步或外部操作。 如果一个线程执行了一个线程分歧动作，那么它将跟随无数的线程分歧动作.



    //////////////////////////////////////未完待续 P648 ////////////////////////////////////////

    /

```