### 红黑树插入流程说明

`假设新插入的节点为：X，X的颜色应该为红色`

- 若X是根节点，将其变成黑色即可

- 若X的父节点是黑色，则不需要任何的操作

- 若X的父节点是红色，叔叔节点（隶属于同一个父节点）也是红色

    1. 将X的父节点与叔叔节点变成黑色

    2. 将X的爷爷节点变成红色

    3. X的爷爷节点变成红色后，有可能会出现连续红色节点的冲突，若有的话则将X的爷爷节点当作是新插入的节点，继续重复操作，直到当前节点是根节点，最后将根节点变成黑色。

- 若X的父节点是红色，叔叔节点是黑色（空）：

    1. X和X的父节点在X的爷爷节点的左子树上（左左情况）

    2. X和X的父节点在X的爷爷节点的右子树上（右右情况）

    3. 以上的两种情况都是同一个处理办法

        1. 将X的父节点与X的爷爷节点进行颜色互换（此时X的父节点是红色，而X的爷爷节点应该是黑色，故而颜色互换应该X的父节点变成黑色，X的爷爷节点变成红色）

        2. 将X的爷爷节点进行左/右旋，左左情况是右旋，右右情况是左旋
    
    4. X的父节点在X的爷爷节点的左子树上，X在X的父节点的右子树上（左右情况）

    5. X的父节点在X的爷爷节点的右子树上，X在X的父节点的左子树上（右左情况）

    6. 以上的两种情况都是同一个处理办法

        1. 将X的父节点进行左/右旋，左右情况是左旋，右左情况是右旋

        2. 下面的处理情况与上面的左左/右右情况是一样的

        3. 注意旋转后，发现情况出现了和上面左左/右右情况是一样的， 所以`X的父节点`将当作新插入的节点继续执行上面的操作

        4. 执行上面操作的时候会进行旋转，左右情况是右旋，右左情况是左旋，因为之前是旋转过一次了


### 红黑树删除流程说明（该流程可能有点问题，后期需要更改，更改完毕后参考TreeMap的实现）

`假设删除的节点为：X`

- X没有子节点的情况：

    1. X为红色，不需要任何处理，直接删除

    2. X为黑色，X的兄弟节点没有子节点

        1. 那么X的兄弟节点肯定也为黑色，不然就违背了任意路径黑色数目不一致的情况

        2. 删除X

        3. 将X的兄弟节点变成红色，X的父节点变成黑色
    
    3. X为黑色，X的兄弟节点只有一个子节点

        1. X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况）

        2. X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）

        3. 以上的两种情况都是同一个处理办法

            1. 删除X

            2. 将X的父节点与X的兄弟节点进行颜色互换

            3. 将X的父节点变成黑色

            4. 将X的兄弟节点的子节点变成黑色

            5. 将X的父节点进行左/右旋，左左情况是右旋，右右情况是左旋
        
        4. X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况）

        5. X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）

            1. 删除X

            2. 将X的兄弟节点与X的兄弟节点的子节点进行颜色互换

            3. 将X的兄弟节点进行左/右旋，左右情况是左旋，右左情况是右旋

            4. 将X的父节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，后面是另外一个旋转，就比如左右，先左旋在右旋

            5. 将X的父节点与X的兄弟节点变成黑色

            6. 将X的父节点的父节点变成红色


    4. X为黑色，X的兄弟节点有两个子节点（若是叶子节点则和上面的12没什么区别，所以这里不是叶子节点）

        1. X的兄弟节点为黑色，那么它的两个子节点必定都是红色（因为X没有子节点，这种情况不用考虑子节点，因为即使旋转了红色的节点并不会影响黑色数目），这样子才能保持黑色数目一样

            1. 删除X

            2. X的父节点进行左/右旋，X在左子树是左旋，X在右子树是右旋

            3. 将X的父节点与X的兄弟节点的左/右子节点变成黑色，X在左子树上就将右子节点变成黑色，X在右子树上就将左子节点变成黑色

            4. 若X的兄弟节点是根节点则不需要变化，将X的兄弟节点变成红色
        
        2. X的兄弟节点为红色，那么它的两个子节点必定是黑色（只考虑X的兄弟节点的子节点与X同边，就比如X在左子树，那么只考虑X的兄弟节点的左子树，因为只有左子树才会在旋转之后移动到了X的那一侧，影响到了黑色数目，而右子树始终没有变动），这样子才能保证黑色数目一样

            1. X的兄弟节点的子节点都无子节点

                1. 删除X

                2. X的父节点与X的兄弟节点颜色互换

                3. X的父节点左/右旋，X在左子树是左旋，X在右子树是右旋

                4. X的父节点与X的父节点的子节点（旋转过后的子节点）颜色互换


            2. X的兄弟节点的子节点只有一个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的子节点必为红色，

                1. 删除X

                2. x的父节点左/右旋，x在左子树是左旋，x在右子树右旋

                3. x的父节点与X的兄弟节点颜色互换

                4. 若X的父节点的左/右子树（旋转过后）的左/右子树与X同边，简单来说，若X在左/右子树，那么只考虑X的父节点的右/左子树的左/右子树，先从5开始执行，若是没对应上则先从7开始执行，同理X在右子树上

                5. X在左/右子树，X的父节点的右/左子树进行右/左旋

                6. X在左/右子树，X的父节点的右/左子树与X的父节点的右/左子树的右/左子树进行颜色互换

                7. X的父节点左/右旋，x在左子树是左旋，x在右子树右旋

                8. X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）

            3. X的兄弟节点的子节点有两个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的两个子节点都为红色，

                1. 删除X

                2. x的父节点左/右旋，x在左子树是左旋，x在右子树右旋

                3. x的父节点与X的兄弟节点颜色互换

                4. x的父节点左/右旋，x在左子树是左旋，x在右子树右旋

                5. X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）


- X只有一个子节点的情况：

    1. X为红色，其子节点只能为黑色，不存在这样子的情况，要不然黑色数目就不一致了（X->叶节点路径上黑色数目不一致）

    2. X为黑色，其子节点只能为红色（左右都无所谓）

        1. 删除X

        2. 将X的子节点变成黑色，并作为X的父节点的子节点


- X有两个子节点的情况：

    1. 找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，相当于X换了个位置。由于是最左的节点，那么它肯定没有左子树，所以它要么是没有子节点要么是只有一个子节点，然后删除节点就变成了上面的情况：

        1. X没有子节点

        2. X只有一个子节点

        3. 剩下的处理情况就和上面的一致了

    2. 找到X的左子树中最右的节点，将两个节点的值进行交换。由于是最右的节点，那么它肯定没有右子树，所以它要么是没有子节点要么是只有一个子节点，然后删除节点就变成了上面的情况：

        1. X没有子节点

        2. X只有一个子节点

        3. 剩下的处理情况就和上面的一致了
        
    3. 以上两种方案根据需求自行选择

    
